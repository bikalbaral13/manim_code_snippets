############## NOTES#############
1) shapely is imported which is a good library to work with polygons. It has a function that checks intersection of two lines and also finds whether a point lies inside a polygon or not.
2) Linestring command checks for the intersection of two lines (x1,y1)__(x2,y2) and (x1,y1)___ (x2,y2)
#

from shapely.geometry import Point
from shapely.geometry import polygon
from shapely.geometry import  LineString

class reflect_dot_inside_polygon(Scene):
   
    def construct(self):
        # Introduction

        intro_text = Text("Reflection inside a Polygon", size=1.5)
        self.play(Write(intro_text))
        self.play(intro_text.animate.shift(UP * 3.5).scale(0.5))
        self.wait(2)

        #Getting Inputs

        vertices=[(-4,0,0),(4,-3,0),(5,0,0),(5,3,0),(2,3,0)]
        poly = Polygon(*vertices)
        _polygon =polygon.Polygon([(-4,0),(4,-3),(5,0),(5,3),(2,3)])
        self.play(Write(poly))

        iter = 200                 # number of iterations
        theta = 120* DEGREES                # starting angle
        start_pt=(0,0,0)             # starting_point
        m = np.tan(theta)                   # Throwing slope
        dt = 0.3             # small change in coordinates
        dot = Dot(radius=0.05, color=BLUE).move_to(RIGHT*(start_pt[0])+UP*start_pt[1])  # Dot information
        self.play(Write(dot))

        x_cor = start_pt[0]
        y_cor = start_pt[1]

        for i in range(iter):

            line_1 = LineString([(x_cor, y_cor), (x_cor + dt * np.cos(theta), y_cor + dt * np.sin(theta))])

            for j in range(5):
                x_1 = vertices[j][0]
                y_1 = vertices[j][1]
                x_2 = vertices[(j+1)%5][0]
                y_2 = vertices[(j+1)%5][1]
                line_2 = LineString([(x_1, y_1), (x_2,y_2)])

                if line_1.intersects(line_2)== True :
                    nearest_theta=np.arctan2((y_2 - y_1),  x_2 - x_1)
                    theta = 2 * nearest_theta - theta
            x_cor = x_cor + dt * np.cos(theta)
            y_cor = y_cor + dt * np.sin(theta)
            dot2 = Dot([x_cor, y_cor, 0], radius=0.05)
            self.play(Transform(dot, dot2), run_time=0.01)
        self.wait(2)
